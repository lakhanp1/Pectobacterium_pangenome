# Prophage analysis in *Pectobacterium* pangenome

## Workflow

```mermaid

```

## Detect prophages in pangenome

### genomad prophage detection

```bash
# run genomad and checkv pipeline
nohup \
cat data/reference_data/assembly_ids.txt | \
parallel --jobs 6 --workdir $PWD --halt now,fail=1 \
--keep-order --results logs/genomad/{} \
--joblog logs/genomad/parallel.log \
scripts/preprocessing/genomad_prophage_annotation.sh {} \
>>logs/genomad/nohup.out 2>&1 &

# count of prophage detected in each genome
for i in `cat data/reference_data/assembly_ids.txt`
do
  printf "$i\t"
  tail -n +2 data/prophage_genomad/$i/${i}_summary/${i}_virus_summary.tsv | wc -l
done | sort -nr -k2

```

Check the checkV contamination.tsv file to see if there is any other contamination
than the expected `host,viral`, `viral,host` and `host,viral,host` ones.

```bash
for cn in `find -name '*contamination.tsv'`
do
cat $cn | awk '$9 != "NA" && NR != 1 && $9 != "host,viral" && $9 != "viral,host" && $9 != "host,viral,host"'
done
```

### Post processing of prophages 

Process genomad output and separate prophages into independent FASTA files. Each
prophage is assigned a unique identifier with format `g_{genome}.vir_{#count}`.
Prophages are saved in independent FASTA files for downstream analysis, for e.g.
ANI clustering of prophages.

```bash
# post processing of prophage data
Rscript scripts/preprocessing/genomad_checkv_merge.R

# save prophages independently
bash scripts/preprocessing/prophage_genomes_extract.sh
```

Extract homology groups for prophages from the pangenome org.db object.

```bash
Rscript scripts/analysis/prophage_homology_groups.R
```


Run ANI on prophage genomes to identify the representative prophages in the 
pangenome.

```bash
# list prophage FASTA files
ls data/prophage_genomad/phage_seqs/*.fna  > data/prophage_genomad/prophage_fasta.list

# run fastANI
fastANI --ql data/prophage_genomad/prophage_fasta.list \
--rl data/prophage_genomad/prophage_fasta.list \
--threads 30 --matrix --visualize --fragLen 500 \
-o data/prophage_genomad/prophage_ANI

# use mash for distance estimation
mkdir data/prophage_genomad/mash

mash sketch -p 30 -s 15000 -k 17 -o data/prophage_genomad/mash/prophages_ref \
-l data/prophage_genomad/prophage_fasta.list >logs/prophage/mash.log 2>&1

mash info data/prophage_genomad/mash/prophages_ref.msh > \
data/prophage_genomad/mash/prophage_sketch_info.txt

mash dist -p 30 data/prophage_genomad/mash/prophages_ref.msh \
data/prophage_genomad/mash/prophages_ref.msh > \
data/prophage_genomad/mash/prophage_distance.tab

```

### QC

Identify the fragmented prophages resulting because of the genome assembly
that can be merged into a complete prophage. Prepare a consolidated list of 
prophages which will be used for the subsequent analysis.

```bash
Rscript scripts/analysis/prophage_merge.R
```

Summarize the consolidated prophage list to generate various statistics and 
generate summary plots. Prophages that are fragmented or smaller than the length
cutoff are removed and the filtered list of prophages is saved for downstream
analysis.

```bash
Rscript scripts/analysis/prophage_summary.R
```

Process prophage MASH and ANI results and visualize MASH similarity matrix for
the filtered prophages.

```bash
Rscript scripts/analysis/prophage_seq_similarity.qmd
```


## Cluster prophages

Use shared homology groups between two prophages to establish the child-parent
relationship between the prophages in pangenome. First, all vs all syntenic
Jaccard similarity is calculated between the prophages. This information is later
used to cluster the prophages using two different approaches.

```bash
Rscript scripts/analysis/prophage_pairwise_similarity.R
```

### Approach 1

A heuristic DAG construcion is extracted from the output of the script 
`scripts/analysis/prophage_merge.R`. This output includes a best matching parent
prophage for each prophage. This is further processed to build a DAG and
visualize the clusters.

Post processing of the child-parent relationships to add additional metadata
and save a DAG in tabular format:

```bash
Rscript scripts/analysis/prophage_DAG_postprocess.R
```

Visualize the clusters of prophages as directed acyclic graphs:

```r
knitr::knit("scripts/analysis/prophage_DAG_viz.qmd")
```

### Approach 2

We first tried to use the Affinity propagation (AP) clustering to group the
prophages into clusters and have a set of cluster representatives. However,
we encountered some clusters generated by the AP clustering where the cluster
members did not even share a homology group. Therefore, we decided not to use
AP clustering.

```r
knitr::knit("scripts/analysis/prophage_AP_clustering.qmd")
```

Cluster the all-vs-all syntenic Jaccard distance matrix using "complete" linkage
hierarchical clustering and cut the cluster using carotovoricin cluster as a
reference.

```r
knitr::knit("scripts/analysis/prophage_clustering.qmd")
```


### Summarize prophage clusters

Summarize the representative prophages in the pangenome.

```bash
Rscript scripts/analysis/prophage_representative_summary.qmd
```

Visualize the representative prophages across pangenome. Use MASH distance to
cluster prophages and ANI distance to cluster the genomes in the pangenome.

```bash
Rscript scripts/analysis/prophage_pangenome_viz.qmd
```

Visualize homology group sets for selected prophages as PAV heatmap across the
pangenome. Replace the code block in `scripts/analysis/homology_group_viz.R` 
script with the following.

```r
analysisName <- "vir_lineage_prophages"

outDir <- file.path(confs$analysis$prophages$dir)
outPrefix <- file.path(outDir, analysisName)

setIds <- c(
  "g_189.vir_2", "g_400.vir_2", "g_399.vir_2", "g_448.vir_2", "g_189.vir_1", 
  "g_3.vir_4", "g_438.vir_3", "g_350.vir_1",
  "g_172.vir_2", "g_393.vir_1"
)
```

Finally, run the script to generate the plot.

```bash
Rscript scripts/analysis/homology_group_viz.R
```

## Individual prophage cluster analysis

Script `scripts/analysis/clustersmap_data_prophages.R` is used to combine the
prophages, homology groups and phylogeny to generate input for `clustermap.js`
visualization tool and generate a report. Below, some configuration is provided
for individual prophage clusters.

### phage_grp_1 or carotovoricin cluster

```r
grpToView <- "phage_grp_1"
subSample <- TRUE
cutHeight <- 2
addFlankingRegions <- TRUE
flankingRegion <- 5000

# ordering factor for prophages: host phylogeny, prophage HG PAV, prophage MASH,
# completeness score
clusterOrder <- "cluster_mash"  # completeness, host, hg_pav, cluster_mash
```

#### carotovoricin cluster absent in some *P. brasiliense* isolates

ybiB: hg_22427603

tolC_2: hg_22427641

*P. brasiliense* lacking CTV cluster: g_149, g_177, g_182, g_185, g_236

```r
grpToView <- "ctv_pbr"
subSample <- TRUE
cutHeight <- 1.5
addFlankingRegions <- TRUE
flankingRegion <- 5000

# ordering factor for prophages: host phylogeny, prophage HG PAV, prophage MASH,
# completeness score
clusterOrder <- "cluster_mash"  # completeness, host, hg_pav, cluster_mash

appendRegions <- list(
  g_177_reg = list(
    chr = "NZ_JACGEP010000002.1", start = 102351, end = 102361, genomeId = "g_177"
  ),
  g_182_reg = list(
    chr = "NZ_JACGZZ010000050.1", start = 81625, end = 81635, genomeId = "g_182"
  ),
  g_185_reg = list(
    chr = "NZ_JACGEN010000006.1", start = 81657, end = 81667, genomeId = "g_185"
  ),
  g_236_reg = list(
    chr = "NZ_JACDSF010000027.1", start = 89639, end = 89649, genomeId = "g_236"
  )
)

appendPhages <- c("g_408.vir_3", "g_403.vir_3", "g_175.vir_3", "g_399.vir_3")


grp <- list(
  phage_grp = grpToView,
  members = dplyr::filter(
    regionClusters,
    SpeciesName == "P. brasiliense", nFragments == 1, phage_grp == "phage_grp_1",
    !prophage_id %in% c("g_408.vir_3", "g_403.vir_3", "g_399.vir_3")
  ) %>%
    dplyr::pull(prophage_id)
)

```

Prophage clusters found in the ctv-lacking Pbr: phage_grp_30, phage_grp_6, phage_grp_29

#### Carotovoricin cluster in *P. versatile*

```r
grpToView <- "ctv_pvs"
subSample <- TRUE
cutHeight <- 1.5
addFlankingRegions <- TRUE
flankingRegion <- 5000


grp <- list(
  phage_grp = grpToView,
  members = dplyr::filter(
    regionClusters,
    SpeciesName == "P. versatile", nFragments == 1, phage_grp == "phage_grp_1"
  ) %>%
    dplyr::pull(prophage_id)
)
```

##### CTV cluster in *P. versatile* collected from France

```r
grpToView <- "ctv_pvs_fr"
subSample <- TRUE
cutHeight <- 1.5
addFlankingRegions <- TRUE
flankingRegion <- 5000

grp <- list(
  phage_grp = grpToView,
  members = dplyr::filter(
    regionClusters,
    SpeciesName == "P. versatile", nFragments == 1, phage_grp == "phage_grp_1",
    geo_loc_country == "France"
  ) %>%
    dplyr::pull(prophage_id)
)
```

### phage_grp_46: highly conserved in all but 5 genomes from n23 clade

```r

```

### phage_grp_71

```r
grpToView <- "phage_grp_71"
subSample <- FALSE
addFlankingRegions <- TRUE 
flankingRegion <- 5000

# ordering factor for prophages: host phylogeny, prophage HG PAV, prophage MASH,
# completeness score
clusterOrder <- "hg_pav"  # completeness, host, hg_pav, cluster_mash

```

### phage_grp_36

```r
grpToView <- "phage_grp_36"
subSample <- FALSE
cutHeight <- 1.5
addFlankingRegions <- TRUE
flankingRegion <- 5000

# ordering factor for prophages: host phylogeny, prophage HG PAV, prophage MASH,
# completeness score
clusterOrder <- "host" # completeness, host, hg_pav, cluster_mash
```

### phage_grp_50

```r
grpToView <- "phage_grp_50"
subSample <- FALSE
addFlankingRegions <- TRUE 
flankingRegion <- 10000

# ordering factor for prophages: host phylogeny, prophage HG PAV, prophage MASH,
# completeness score
clusterOrder <- "cluster_mash"  # completeness, host, hg_pav, cluster_mash
```

### phage_grp_21

```r
grpToView <- "phage_grp_21"
subSample <- FALSE
addFlankingRegions <- TRUE
flankingRegion <- 5000

# ordering factor for prophages: host phylogeny, prophage HG PAV, prophage MASH,
# completeness score
clusterOrder <- "cluster_mash"  # completeness, host, hg_pav, cluster_mash
```

## Carotovoricin tail fiber variation reion MSA

Extract the region between the two homology groups, `r c("hg_22427604", "hg_22427603")`
for the carotovoricin cluster. Additionally, generate `GFF3` files with the
homology group, COG, PFAM and other metadata information to visualize.

```bash
Rscript scripts/analysis/clustermap_get_regions.R
```

Extract DNA sequence for these 3' tail fiber regions.

```bash
mkdir analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/region_fasta

tail -n +2 analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/ctv_pbr.variable_regions.tab |
  cut -f 1,3-5 |
  while read name sampleId pos strand; do
    rc=""
    if [ ${strand} == "-" ]; then
        rc="--reverse-complement"
    fi
    outFa="analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/region_fasta/${name}.fasta"

    seq=">${name} ${pos}(${strand})\n"
    seq+=`samtools faidx ${rc} data/prokka_annotation/${sampleId}/${sampleId}.fna $pos | tail -n +2`
    printf "${seq}\n" > ${outFa}
    printf "${seq}\n"
  done >analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/ctv_pbr.variable_regions.fasta

```

Mauve aligns sequences provided in `fasta` and `genbank` format. However, the
sequence annotation is shown only if the alignment input was in `genbank`
format. Therefore, we need to combine the homology group annotation in `gff3`
format with the `fasta` sequences to generate a `genbank` formatted files. To
do this, Emboss tool `seqret` was used.

```bash
conda activate omics_py37

cd analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/region_fasta

for vir in `cut -f 1 ../ctv_pbr.variable_regions.tab | tail -n +2`
do
  seqret -sequence ${vir}.fasta -feature -fformat gff3 \
  -fopenfile ${vir}.gff3 -osformat genbank -osextension gbk \
  -osname_outseq ${vir} -ofdirectory_outseq gbk_file -auto 
done

sed -i.bak -r -e 's/(^\s+CDS\s+(complement\()?)[^:]+:([[:digit:]]+\.\.[[:digit:]]+\)?).*/\1\3/' \
  -e 's/\/note="\*([^:]+): /\/\1="/' *.gbk 

```

Align and visualize sequences using Mauve.

```bash
mauve_out="ctv_pbr"

/Applications/Mauve.app/Contents/MacOS/progressiveMauve \
--output="${mauve_out}.mauve.xmfa" \
--backbone-output="${mauve_out}.mauve.backbone" \
--output-guide-tree="${mauve_out}.mauve.guide_tree.newick" \
region_fasta/g_302.vir_3.gbk region_fasta/g_364.vir_2.gbk \
region_fasta/g_337.vir_1.gbk region_fasta/g_439.vir_2.gbk \
region_fasta/g_403.vir_3.gbk region_fasta/g_399.vir_3.gbk \
region_fasta/g_175.vir_3.gbk region_fasta/g_408.vir_3.gbk \
region_fasta/g_138.vir_2.gbk \
region_fasta/g_368.vir_3.gbk region_fasta/g_345.vir_1.gbk \
region_fasta/g_366.vir_3.gbk region_fasta/g_308.vir_2.gbk \
region_fasta/g_191.vir_1.gbk region_fasta/g_173.vir_2.gbk \
region_fasta/g_155.vir_1.gbk region_fasta/g_166.vir_2.gbk \
region_fasta/g_299.vir_1.gbk region_fasta/g_438.vir_2.gbk \
region_fasta/g_263.vir_2.gbk region_fasta/g_43.vir_1.gbk \
region_fasta/g_391.vir_3.gbk  > "${mauve_out}".log 2>&1

mauve_out="ctv_pbr.ein"

/Applications/Mauve.app/Contents/MacOS/progressiveMauve \
--output="${mauve_out}.mauve.xmfa" \
--backbone-output="${mauve_out}.mauve.backbone" \
--output-guide-tree="${mauve_out}.mauve.guide_tree.newick" \
region_fasta/g_345.vir_1.gbk region_fasta/g_366.vir_3.gbk \
region_fasta/g_308.vir_2.gbk region_fasta/g_191.vir_1.gbk \
region_fasta/g_173.vir_2.gbk region_fasta/g_155.vir_1.gbk \
region_fasta/g_166.vir_2.gbk  > "${mauve_out}".log 2>&1


mauve_out="ctv_pbr.rep"

/Applications/Mauve.app/Contents/MacOS/progressiveMauve \
--output="${mauve_out}.mauve.xmfa" \
--backbone-output="${mauve_out}.mauve.backbone" \
--output-guide-tree="${mauve_out}.mauve.guide_tree.newick" \
region_fasta/g_302.vir_3.gbk region_fasta/g_337.vir_1.gbk \
region_fasta/g_175.vir_3.gbk region_fasta/g_173.vir_2.gbk \
region_fasta/g_299.vir_1.gbk region_fasta/g_438.vir_2.gbk \
region_fasta/g_391.vir_3.gbk  > "${mauve_out}".log 2>&1

```

Perform MSA using `MAFFT`

```bash
conda activate pantools_v4_3
cd analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/

mafft --globalpair --quiet --maxiterate 1000 --treeout ctv_pbr.variable_regions.fasta
```

Smash++ pairwise sequence comparison

```bash
conda activate omics_py37

cd analysis/pangenome_v2/prophages/cluster_viz/ctv_pbr/region_fasta

function smashpp_compare
{
  smashpp -r $1 -t $2
  smashpp viz -o $(basename $1 .fasta)$(basename $2 .fasta)".svg" "${1}.${2}.pos"
}

export -f smashpp_compare

smashpp_compare g_345.vir_1.fasta g_345.vir_1.fasta 
smashpp_compare g_345.vir_1.fasta g_366.vir_3.fasta 
smashpp_compare g_345.vir_1.fasta g_302.vir_3.fasta
smashpp_compare g_345.vir_1.fasta g_403.vir_3.fasta
smashpp_compare g_345.vir_1.fasta g_173.vir_2.fasta
smashpp_compare g_345.vir_1.fasta g_138.vir_2.fasta
smashpp_compare g_345.vir_1.fasta g_263.vir_2.fasta
smashpp_compare g_345.vir_1.fasta g_155.vir_1.fasta

```

Left inverted repeat for Ein: CTCCCGCAAACCTCGGTTTTGGGGAC (CTCCCGCAAACCTCGGTTT)
Left inverted repeat for Ein(rev-com): GTCCCCAAAACCGAGGTTTGCGGGAG (AAACCGAGGTTTGCGGGAG, AAACCGAGGTTTGCG)

Right inverted repeat for Ein: TTCTCGCAAACCTCGGTTTTGGAGAA
Right inverted repeat for Ein(rev): AAGAGGTTTTGGCTCCAAACGCTCTT
Right inverted repeat for Ein(rev-com): TTCTCCAAAACCGAGGTTTGCGAGAA (AAACCGAGGTTTGCGAGAA, AAACCGAGGTTTGCG)
Right inverted repeat for Ein(comp): AAGAGCGTTTGGAGCCAAAACCTCTT
